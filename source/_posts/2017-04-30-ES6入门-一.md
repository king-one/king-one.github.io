---
title: ES6入门(一)
date: 2017-04-30 16:42:39
categories: 技术
tags: [ES6,javascript]
---
ECMAScript 6.0（以下简称**ES6**）是 JavaScript 语言的下一代标准，已经在2015年6月正式发布了。它的目标，是使得 JavaScript 语言可以用来编写复杂的大型应用程序，成为企业级开发语言。ES6 既是一个历史名词，也是一个泛指，含义是5.1版以后的 JavaScript 的下一代标准，涵盖了ES2015、ES2016、ES2017等等，而ES2015 则是正式名称，特指该年发布的正式版本的语言标准。提到 ES6 的地方，一般是指 ES2015 标准，但有时也是泛指“下一代 JavaScript 语言”。
<!-- more -->
### 1.let命令
之前js只有函数作用域，ES6新增了`let`命令，用来声明变量。它的用法类似于`var`，但是所声明的变量，只在`let`命令所在的代码块内有效。下面一个列子很好的说明了`var`与`let`的区别
```javascript
		var b = [];
			for(var i = 0; i < 10; i++){
			b[i] = function (){
				console.log(i);
			}
		}
		console.log(i); //10
		b[1]()  // 10
		b[6]()  // 10
```
在上述代码中，变量i是var声明的，全局都能访问，每次循环这个全局变量i的的值都会发生变化，而循环内被赋给数组b的function在运行时，会通过闭包读到这同一个变量i，导致最后输出的是最后一轮的i的值，也就是10。

```javascript
		var a = [];
		for(let i = 0; i < 10; i++){
			a[i] = function (){
				console.log(i);
			}
		}
		console.log(i); //undefine
		a[1]();   //1
		a[6]();   //6
```
上面代码中，变量i是let声明的，当前的i只在本轮循环有效，在循环体外会报`undefined `，所以每一次循环的i其实都是一个新的变量，所以最后输出的是6。如果每一轮循环的变量i都是重新声明的，那它怎么知道上一轮循环的值，从而计算出本轮循环的值？这是因为 JavaScript 引擎内部会记住上一轮循环的值，初始化本轮的变量i时，就在上一轮循环的基础上进行计算。也可以说循环体内的 i 和外部的 i 是分离的。下面的i在重新定义后仍然输出了3次。
```javascript
  for (let i = 0; i < 3; i++) {
    let i = 'abc';
    console.log(i);
  }
  //abc
  //abc
  //abc
```
### 暂时性死区
在代码块内，使用`let`命令声明变量之前，该变量都是不可用的。这在语法上，称为“暂时性死区”`（temporal dead zone，简称 TDZ）`。如下:
```javascript
	var temp = 'abc';
	if(true){
      temp = 'abc'; //ReferenceError: tmp is not defined
	  let temp;
	}
```
ES6明确规定，如果区块中存在let和const命令，这个区块对这些命令声明的变量，从一开始就形成了封闭作用域。凡是在声明之前就使用这些变量，就会报错。上面代码中，存在全局变量`temp`，但是块级作用域内`let`又声明了一个局部变量`temp`，导致后者绑定这个块级作用域，所以在`let`声明变量前，用`temp`就会报错。
**隐蔽的死区**
```javascript
	function bar(x = y, y = 2){
			return [x,y];
		}
   bar();  //ReferenceError :  y is not defined
```
上面y赋值给x时还未定义，所以就会报错，改成这样就不会报错了
```javascript
    function bar1(x = 2, y = x ){
	 	   return [x,y]
}
	console.log(bar1())	//[2,2]			
```
ES6 规定暂时性死区和let、const语句不出现变量提升，主要是为了减少运行时错误，防止在变量声明前就使用这个变量，从而导致意料之外的行为。
#### 不允许重复声明
let不允许在相同作用域内，重复声明同一个变量。
```javascript
		function fn(){	
			let a = 10;
			var a = 1;
		}
		fn() //SyntaxError: Identifier 'a' has already been declared
```
**不能在函数内部重新声明参数**
```javascript
		function func(arg) {
		  let arg; 
		}
		func() // Identifier 'arg' has already been declared
```
### 2.块级作用域
es5中应为只有全局作用域和函数作用域，带来的不合理的应用情况：
（1） 内层变量可能会覆盖外层变量
```javascript
	var date1 = new Date();
		function f() {
			console.log(date1); //undefined
			if(false){
				var date1 = 'hello world';
			}
		}
		f()
```
（2）循环变量泄露为全局变量
```javascript
	var  a = 'abc'
    for(var i =0; i < s.lenght; i++){
       console.log(s[i])
    }
   	   console.log(i); //4
```
**ES6的块级作用域**
```javascript
	var n = 10;
	function f1() {
	  let n = 5;
	  if (true) {
	    let n = 10;
	  }
	  console.log(n); 
	}
	f1(); //5
	console.log(n); //10
```
f1函数有两个代码块，都声明了变量n，运行后输出5。这表示外层代码块不受内层代码块的影响。

ES6 引入了块级作用域，明确允许在块级作用域之中声明函数。ES6 规定，块级作用域之中，函数声明语句的行为类似于let，在块级作用域之外不可引用。

本质上，块级作用域是一个语句，将多个操作封装在一起，没有返回值。在块级作用域以外，没有办法得到t的值，因为块级作用域不返回值，除非设为全局变量。
### 3.const 命令
`const`声明的是常量。一旦声明，常量的值就不能改变。
```javascript
const PI = Math.PI
PI = 23 //Module build failed: SyntaxError: /es6/app.js: "PI" is read-only
```
当我们尝试去改变用`const`声明的常量时，浏览器就会报错。对于`const`来说，只声明不赋值，也会报， const命令声明的常量也是不提升，同样存在暂时性死区,不可重复声明.
`const`有一个很好的应用场景，就是当我们引用第三方库的时声明的变量，用`const`来声明可以避免未来不小心重命名而导致出现bug:
```javascript
const monent = require('moment')
```